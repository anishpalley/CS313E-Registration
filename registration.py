"""

Student information for this assignment:



On my/our honor, Anish Palley, this

programming assignment is my own work and I have not provided this code to

any other student.



I have read and understand the course syllabus's guidelines regarding Academic

Integrity. I understand that if I violate the Academic Integrity policy (e.g.

copy code from someone else, have the code generated by an LLM, or give my

code to someone else), the case shall be submitted to the Office of the Dean of

Students. Academic penalties up to and including an F in the course are likely.



UT EID 1: sy23928
UT EID 2: ap65675

"""


import sys





class HeapError(Exception):

    """

    Custom exception class for heap errors.

    """





class BinaryHeap:

    """A modified binary heap implementation from the readings."""



    def __init__(self):

        """

        Initializes an empty binary heap.

        """

        self.__heap = []





    def _perc_up(self, i):

        """

        Moves the element at index i up to its correct position in the heap.

        """

        while (i - 1) // 2 >= 0:

            parent_idx = (i - 1) // 2

            if self.__heap[i] < self.__heap[parent_idx]:

                self.__heap[i], self.__heap[parent_idx] = (

                    self.__heap[parent_idx],

                    self.__heap[i],

                )

            i = parent_idx





    def insert(self, item):

        """

        Inserts a new item into the heap and maintains the heap property.

        """

        self.__heap.append(item)

        self._perc_up(len(self.__heap) - 1)





    def _perc_down(self, i):

        """

        Moves the element at index i down to its correct position in the heap."""

        while 2 * i + 1 < len(self.__heap):

            sm_child = self._get_min_child(i)

            if self.__heap[i] > self.__heap[sm_child]:

                self.__heap[i], self.__heap[sm_child] = (

                    self.__heap[sm_child],

                    self.__heap[i],

                )

            else:

                break

            i = sm_child





    def _get_min_child(self, i):

        """

        Returns the index of the smaller child of the node at index i.

        """

        if 2 * i + 2 > len(self.__heap) - 1:

            return 2 * i + 1

        if self.__heap[2 * i + 1] < self.__heap[2 * i + 2]:

            return 2 * i + 1

        return 2 * i + 2





    def delete(self):

        """

        Removes and returns the smallest item from the heap."""

        if self.is_empty():

            raise HeapError("Heap is empty")

        self.__heap[0], self.__heap[-1] = self.__heap[-1], self.__heap[0]

        result = self.__heap.pop()

        self._perc_down(0)

        return result





    def peek(self):

        """

        Returns the smallest item from the heap without removing it.

        """

        if self.is_empty():

            raise IndexError("Heap is empty")

        return self.__heap[0]





    def is_empty(self):

        """

        Checks if the heap is empty."""

        return len(self.__heap) == 0





    def heapify(self, not_a_heap):

        """

        Converts a list into a heap in O(n) time."""

        self.__heap = not_a_heap[:]

        i = len(self.__heap) // 2 - 1

        while i >= 0:

            self._perc_down(i)

            i = i - 1





class Node:

    """

    Represents a node in a singly linked list.



    Instance Variables:

        data: The value or data stored in the node.

        next: The reference to the next node in the linked list (None by default).

    """



    def __init__(self, data, link=None):

        """

        Initializes a new node with the given data and a reference to the next node.



        Args:

            data: The data to store in the node.

            next: Optional; the next node in the linked list (None by default).

        """

        self.data = data

        self.next = link





    @property

    def next(self):

        """

        Getter method for the next attribute.

        """

        return self.__next





    @next.setter

    def next(self, value):

        """

        Setter method for the next attribute.

        """

        if value is None or isinstance(value, Node):

            self.__next = value

        else:

            raise ValueError("Next must be a Node instance or None.")





class StackError(Exception):

    """

    Custom exception class for stack errors.

    """





class Stack:

    """

    A class that implements a stack using a singly linked list.



    Instance Variables:

        _top: The top node of the stack.

        _size: The number of elements in the stack.

    """



    def __init__(self):

        """

        Initializes an empty stack with no elements.

        """

        self._top = None

        self._size = 0





    def peek(self):

        """

        Returns the value at the top of the stack without removing it.



        Raises:

            StackError: If the stack is empty, raises "Peek from empty stack.".



        Returns:

            The data stored in the top node of the stack.

        """

        if self.is_empty():

            raise StackError("Peek from empty stack.")

        return self._top.data





    def push(self, item):

        """

        Pushes a new item onto the top of the stack.



        Args:

            item: The data to push onto the stack.

        """

        new_node = Node(item)

        new_node.next = self._top

        self._top = new_node

        self._size += 1





    def pop(self):

        """

        Removes and returns the item at the top of the stack.



        Raises:

            StackError: If the stack is empty, raises "Pop from empty stack.".



        Returns:

            The data from the top node of the stack.

        """

        if self.is_empty():

            raise StackError("Pop from empty stack.")

        removed_data = self._top.data

        self._top = self._top.next

        self._size -= 1

        return removed_data





    def is_empty(self):

        """

        Checks if the stack is empty.



        Returns:

            True if the stack is empty, False otherwise.

        """

        return self._top is None





    def size(self):

        """

        Returns the number of items in the stack.



        Returns:

            The size of the stack as an integer.

        """

        return self._size





class Vertex:

    """Vertex Class using properties and setters for better encapsulation."""



    def __init__(self, label):

        self.__label = label

        self.visited = False

        self.depth = -1





    @property

    def visited(self):

        """Property to get the visited status of the vertex."""

        return self.__visited





    @visited.setter

    def visited(self, value):

        """Setter to set the visited status of the vertex."""

        if isinstance(value, bool):

            self.__visited = value

        else:

            raise ValueError("Visited status must be a boolean value.")





    @property

    def depth(self):

        """Property to get the depth of the vertex. This is the number of prereqs

        that need to be completed before this course."""

        return self.__depth





    @depth.setter

    def depth(self, value):

        """Setter to set the visited status of the vertex."""

        if isinstance(value, int):

            self.__depth = value

        else:

            raise ValueError("Depth must be a integer value.")





    @property

    def label(self):

        """Property to get the label of the vertex."""

        return self.__label





    def __str__(self):

        """String representation of the vertex"""

        return str(self.__label)





class Graph:

    """A Class to present a Graph."""



    def __init__(self):

        self.vertices = []  # a list of vertex objects

        self.adjacency_matrix = []  # adjacency matrix of edges





    def has_vertex(self, label):

        """Check if a vertex is already in the graph"""

        num_vertices = len(self.vertices)

        for i in range(num_vertices):

            if label == self.vertices[i].label:

                return True

        return False





    def get_index(self, label):

        """Given a label get the index of a vertex"""

        num_vertices = len(self.vertices)

        for i in range(num_vertices):

            if label == self.vertices[i].label:

                return i

        return -1





    def add_vertex(self, label):

        """Add a Vertex with a given label to the graph"""

        if self.has_vertex(label):

            return



        # add vertex to the list of vertices

        self.vertices.append(Vertex(label))



        # add a new column in the adjacency matrix

        num_vertices = len(self.vertices)

        for i in range(num_vertices - 1):

            self.adjacency_matrix[i].append(0)



        # add a new row for the new vertex

        new_row = []

        for i in range(num_vertices):

            new_row.append(0)

        self.adjacency_matrix.append(new_row)





    def add_edge(self, start, finish):

        """Add unweighted directed edge to graph"""

        self.adjacency_matrix[start][finish] = 1





    def get_adjacent_vertices(self, vertex_index):

        """Return adjacent vertex indices to vertex_index"""

        vertices = []

        num_vertices = len(self.vertices)

        for j in range(num_vertices):

            if self.adjacency_matrix[vertex_index][j]:

                vertices.append(j)

        return vertices



    def compute_depth(self):

        """Computes depth for each vertex in the graph."""

        # recursive approach recommended

        for vertex in self.vertices:

            self.dfs_depth(vertex)



    def dfs_depth(self, start_vertex):

        """

        Recursive helper function for compute_depth.

        """

        # start_vertex_index = self.get_index(start_vertex.label)

        # if not self.get_adjacent_vertices(start_vertex_index):

        #    return start_vertex.depth



        if start_vertex.depth != -1:

            return start_vertex.depth
        current_depth = -1

        start_vertex_index = self.get_index(start_vertex.label)

        for neighbor_index in self.get_adjacent_vertices(start_vertex_index):

            neighbor_vertex = self.vertices[neighbor_index]

            depth = self.dfs_depth(neighbor_vertex)

            current_depth = max(depth, current_depth)

        start_vertex.depth = current_depth + 1

        return start_vertex.depth

    def has_cycle(self):

        """

        Determine whether or not the graph has a cycle.



        post: returns True if there is a cycle and False otherwise.

        """

        # must be implemented using a DFS; recursive approach recommended

        colors = {v: "white" for v in self.vertices}



        for vertex in self.vertices:

            if colors[vertex] == "white":

                if self.dfs_visit(vertex, colors):

                    return True

        return False



    def dfs_visit(self, start_vertex, colors):

        """

        Recursive helper function for has_cycle.

        """

        # if start_vertex.visited is True:

        #    return True

        colors[start_vertex] = "gray"

        start_vertex_index = self.get_index(start_vertex.label)

        for neighbor_index in self.get_adjacent_vertices(start_vertex_index):

            neighbor_vertex = self.vertices[neighbor_index]

            if colors[neighbor_vertex] == "gray":

                return True

            if colors[neighbor_vertex] == "white":

                if self.dfs_visit(neighbor_vertex, colors):

                    return True

        colors[start_vertex] = "black"

        return False

    def get_registration_plan(self):

        """

        Return a valid ordering of courses to take for registration as a 2D

        list of vertex labels, where each inner list will have a maximum of 4 vertices.
        pre: a valid registration plan exists.

        post: returns a 2D list of strings, where each inner list represents a semester

        """
        self.compute_depth()

        courses_len = len(self.vertices)
        pre_reqs = [0] * courses_len

        # Count prerequisites (in-degrees)
        for i in range(courses_len):
            for j in range(courses_len):
                if self.adjacency_matrix[i][j] == 1:
                    pre_reqs[j] += 1

        # Get list of available courses (no prereqs)/
        no_pre_reqs = []
        for i in range(courses_len):
            if pre_reqs[i] == 0:
                no_pre_reqs.append(i)

        result = []

        while len(no_pre_reqs) > 0:
            for i in range(len(no_pre_reqs)-1):
                for j in range(i+1, len(no_pre_reqs)):
                    one = self.vertices[no_pre_reqs[i]]
                    two = self.vertices[no_pre_reqs[j]]
                    if one.depth < two.depth or (one.depth == two.depth and one.label > two.label):
                        temp = no_pre_reqs[i]
                        no_pre_reqs[i] = no_pre_reqs[j]
                        no_pre_reqs[j] = temp

            next_pre_req = []

            while len(no_pre_reqs) >= 4:
                semester = []
                semester.append(self.vertices[no_pre_reqs.pop(0)].label)
                semester.append(self.vertices[no_pre_reqs.pop(0)].label)
                semester.append(self.vertices[no_pre_reqs.pop(0)].label)
                semester.append(self.vertices[no_pre_reqs.pop(0)].label)
                result.append(semester)
                for label in semester:
                    index = -1
                    for i in range(courses_len):
                        if self.vertices[i].label == label:
                            index = i
                            break
                    for j in range(courses_len):
                        if self.adjacency_matrix[index][j] == 1:
                            pre_reqs[j] = pre_reqs[j] - 1
                            if pre_reqs[j] == 0:
                                next_pre_req.append(j)
            if len(no_pre_reqs) > 0:
                semester = []
                while len(no_pre_reqs) > 0:
                    label = self.vertices[no_pre_reqs.pop(0)].label
                    semester.append(label)

                    index = -1
                    for i in range(courses_len):
                        if self.vertices[i].label == label:
                            index = i
                            break
                    for j in range(courses_len):
                        if self.adjacency_matrix[index][j] == 1:
                            pre_reqs[j] = pre_reqs[j] - 1
                            if pre_reqs[j] == 0:
                                next_pre_req.append(j)
                result.append(semester)


            no_pre_reqs = next_pre_req

        return result

def main():

    """

    The main function to retrieve a registration plan.

    The output code has been written for you.

    """
    # create a Graph object

    graph = Graph()
    # read the number of vertices

    number_of_vertices = int(sys.stdin.readline())
    # read the vertices and add them into the graph

    for _ in range(number_of_vertices):

        label = sys.stdin.readline()

        label = label.strip()

        graph.add_vertex(label)
    # read the number of edges

    number_of_edges = int(sys.stdin.readline())
    # read the edges and insert them into the graph

    # you will need to call the method to convert them from their labels to their index

    for _ in range(number_of_edges):

        labels = sys.stdin.readline()

        labels = labels.strip(" ")
        first_label = label[0]

        second_label = label[1]

        first_index = graph.get_index(first_label)

        second_index = graph.get_index(second_label)

        graph.add_edge(first_index, second_index)

    ####################################################################################

    # DO NOT CHANGE ANYTHING BELOW THIS

    if graph.has_cycle():

        print("Registration plan invalid because a cycle was detected.")

    else:

        print("Valid registration plan detected.")

        graph.compute_depth()



        courses = graph.get_registration_plan()

        print()

        print("Registration plan: ")

        for semester in courses:

            print(semester)

if __name__ == "__main__":

    main()
